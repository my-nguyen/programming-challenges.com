#include <stdio.h>
#include <string.h>
#include <unistd.h> // optarg
#include <stdlib.h> // malloc() and free()
#include "defs.h"


int _debug = DEBUG_OFF;


typedef int bool;
#define false 0
#define true  1


#define MAX_CANDIDATES 20
#define MAX_NAME       80
#define MAX_BALLOTS    400


struct NameList
{
    char _list[MAX_CANDIDATES][MAX_NAME];
    int  _count;
};
typedef struct NameList NameList;


struct Ballot
{
    int _list[MAX_CANDIDATES];
    int _count;
};
typedef struct Ballot Ballot;


struct BallotList
{
    Ballot _list[MAX_BALLOTS];
    int    _count;
};
typedef struct BallotList BallotList;


struct Case
{
    NameList   _names;
    BallotList _ballots;
};
typedef struct Case Case;


struct Candidate
{
    char        _name[MAX_NAME];
    bool        _active;
    BallotList _ballots;
};
typedef struct Candidate Candidate;


struct CandidateList
{
    Candidate _list[MAX_CANDIDATES];
    int       _count;
};
typedef struct CandidateList CandidateList;


struct IndexList
{
    int _list[MAX_CANDIDATES];
    int _count;
};
typedef struct IndexList IndexList;


struct Node
{
    Candidate    _candidate;
    struct Node* _prev;
    struct Node* _next;
};
typedef struct Node Node;


struct LinkedList
{
    Node* _head;
    Node* _tail;
};
typedef struct LinkedList LinkedList;


void nl_print(NameList* names)
{
    int i;
    for (i = 0; i < names->_count; i++)
        printf("%s\n", names->_list[i]);
}


// extract the integers from a line representing a ballot, which is an array
// of integers
void b_add_string(Ballot* ballot, char* line)
{
    // use a temporary copy to preserve the input line
    char tmp[MAX_LINE];
    strcpy(tmp, line);
    char* token = strtok(tmp, " ");
    ballot->_count = 0;
    while (token != 0)
    {
        ballot->_list[ballot->_count] = atoi(token);
        ballot->_count++;
        token = strtok(0, " \n");
    }
}


Ballot* b_add_ballot(Ballot* this, Ballot* that)
{
    if (this != that)
    {
        int i;
        for (i = 0; i < that->_count; i++)
            this->_list[i] = that->_list[i];
        this->_count = that->_count;
    }

    return this;
}


void b_print(Ballot* ballot)
{
    int i;
    for (i = 0; i < ballot->_count; i++)
        printf("%d ", ballot->_list[i]);
    printf("\n");
}


void b_shift_left(Ballot* ballot)
{
    int out = ballot->_list[0];
    int i;
    for (i = 0; i < ballot->_count-1; i++)
        ballot->_list[i] = ballot->_list[i+1];
    ballot->_list[ballot->_count-1] = out;
}


void bl_init(BallotList* this, BallotList* that)
{
    if (that == 0)
        this->_count = 0;
    else
    {
        int i;
        for (i = 0; i < that->_count; i++)
            b_add_ballot(this->_list+i, that->_list+i);
        this->_count = that->_count;
    }
}


void bl_add_ballot(BallotList* list, Ballot* ballot)
{
    b_add_ballot(list->_list+list->_count, ballot);
    list->_count++;
}


// go through the list of ballots and record all the ballots whose first
// choice is the current candidate
void bl_add_ballots(BallotList* this, BallotList* that)
{
    int i;
    for (i = 0; i < that->_count; i++)
        if (that->_list[i]._list[0] == this->_list[0]._list[0])
            bl_add_ballot(this, that->_list+i);
}


void bl_add_string(BallotList* list, char* line)
{
    b_add_string(list->_list+list->_count, line);
    list->_count++;
}


BallotList* bl_copy(BallotList* this, BallotList* that)
{
    if (this != that)
    {
        int i;
        for (i = 0; i < that->_count; i++)
            b_add_ballot(this->_list+i, that->_list+i);
        this->_count = that->_count;
    }

    return this;
}


void bl_print(BallotList* ballots)
{
    int i;
    for (i = 0; i < ballots->_count; i++)
    {
        printf("BALLOT %d: ", i);
        b_print(ballots->_list + i);
    }
}


void cl_print(CandidateList* candidates);
void bl_shift_left(BallotList* ballots, CandidateList* candidates)
{
    int i;
    for (i = 0; i < ballots->_count; i++)
    {
        int index = ballots->_list[i]._list[0] - 1;
        while (candidates->_list[index]._active == false)
        {
            b_shift_left(ballots->_list+i);
            index = ballots->_list[i]._list[0] - 1;
        }
    }
}


void cs_print(Case* record)
{
    nl_print(&record->_names);
    bl_print(&record->_ballots);
}


void cn_init(Candidate* candidate, char* name, bool active, BallotList* ballots)
{
    strcpy(candidate->_name, name);
    candidate->_active = active;
    bl_init(&candidate->_ballots, ballots);
}


void cn_add_ballots(Candidate* candidate, BallotList* ballots)
{
    bl_add_ballots(&candidate->_ballots, ballots);
}


Candidate* cn_copy(Candidate* this, Candidate* that)
{
    if (this != that)
    {
        strcpy(this->_name, that->_name);
        this->_active = that->_active;
        bl_copy(&this->_ballots, &that->_ballots);
    }

    return this;
}


void cl_init(CandidateList* list)
{
    list->_count = 0;
}


void cl_print(CandidateList* candidates)
{
    int i;
    for (i = 0; i < candidates->_count; i++)
        printf("%s: active(%d), votes(%d)\n",
               candidates->_list[i]._name,
               candidates->_list[i]._active,
               candidates->_list[i]._ballots._count);
}


bool cl_find_winner(CandidateList* candidates, int num_ballots)
{
    int i;
    for (i = 0; i < candidates->_count; i++)
        if (candidates->_list[i]._ballots._count / num_ballots >= .5)
        {
            if (_debug >= DEBUG_COPIOUS)
                printf("FOUND WINNER %s\n", candidates->_list[i]._name);
            return true;
        }
    printf("FOUND NO WINNER\n");
    return false;
}


void n_init(Node* node, Candidate* candidate)
{
    cn_copy(&node->_candidate, candidate);
    node->_prev = 0;
    node->_next = 0;
}


void ll_init(LinkedList* list)
{
    list->_head = 0;
    list->_tail = 0;
}


void ll_add(LinkedList* list, Candidate* candidate)
{
    Node* node = malloc(sizeof(Node));
    n_init(node, candidate);

    if (list->_head == 0 && list->_tail == 0) // list is empty
    {
        list->_head = node;
        list->_tail = node;
    }
    else
    {
        list->_tail->_next = node;
        list->_tail = node;
        node->_prev = list->_tail;
    }
}


void ll_delete(LinkedList* list, Node* node)
{
    if (node->_prev == 0)               // node is at the beginning of list
        if (node->_next == 0)           // node is the only one in the list
        {
            list->_head = 0;
            list->_tail = 0;
        }
        else                               // node is somewhere in the middle
        {
            list->_head = node->_next;
            list->_head->_prev = 0;
        }
    else
        if (node->_next == 0)           // node is at the end of list
        {
            list->_tail = node->_prev;
            list->_tail->_next = 0;
        }
        else                               // node is somewhere in the middle
        {
            node->_prev->_next = node->_next;
            node->_next->_prev = node->_prev;
        }

    free(node);
}


void ll_free(LinkedList* list)
{
    Node* current;
    Node* next;
    for (current = list->_head; current != 0; current = next)
    {
        next = current->_next;
        free(current);
    }
}


bool input(char* input_file, Case* list, int* num_cases)
{
    bool success;
    FILE* file = fopen(input_file, "r");
    if (file == 0)
    {
        printf("Cannot open file %s\n", input_file);
        success = false;
    }
    else
    {
        // read the number of test cases
        char line[MAX_LINE];
        fgets(line, MAX_LINE, file);
        *num_cases = atoi(line);


        // read a blank line
        fgets(line, MAX_LINE, file);


        int i;
        for (i = 0; i < *num_cases; i++)
        {
            // read the count of the candidates
            Case* current = list + i;
            fgets(line, MAX_LINE, file);
            current->_names._count = atoi(line);


            // read the candidates' names
            int j;
            for (j = 0; j < current->_names._count; j++)
            {
                fgets(line, MAX_LINE, file);
                strncpy(current->_names._list[j], line, strlen(line)-1);
            }


            // read the ballots, one line at a time. stop when EOF or
            // empty line is fetched
            bl_init(&current->_ballots, 0);
            while (fgets(line, MAX_LINE, file) != 0 && line[0] != '\n')
                bl_add_string(&current->_ballots, line);
        }

        fclose(file);
        success = true;

        if (_debug >= DEBUG_COPIOUS)
        {
            printf("READ %d CASES\n", *num_cases);
            int i;
            for (i = 0; i < *num_cases; i++)
            {
                printf("CASE %d\n", i);
                cs_print(list + i);
            }
        }
    }

    return success;
}


void ll_print(LinkedList* candidates)
{
    Node* node;
    for (node = candidates->_head; node != 0; node = node->_next)
        printf("%s: active(%d), votes(%d)\n", node->_candidate._name,
               node->_candidate._active, node->_candidate._ballots._count);
}


bool ll_find_winner(LinkedList* candidates, int num_ballots)
{
    Node* node;
    for (node = candidates->_head; node != 0; node = node->_next)
        if (node->_candidate._ballots._count / num_ballots >= .5)
        {
            if (_debug >= DEBUG_COPIOUS)
                printf("Found winner %s\n", node->_candidate._name);
            return true;
        }
    printf("Found no winner\n");
    return false;
}


/*
Node* ll_find_index(LinkedList* candidates, int index)
{
    Node* node;
    for (node = candidates->_head; node != 0; node = node->_next)
        if (node->_candidate._index == index)
        {
            if (_debug >= DEBUG_COPIOUS)
                printf("Found candidate %s with index %d\n",
                       node->_candidate._name, index);
            return node;
        }
}
*/


void o_print(IndexList* indices, CandidateList* candidates)
{
    printf("THE OUTCAST:\n");
    int i;
    for (i = 0; i < indices->_count; i++)
    {
        Candidate* candidate = candidates->_list + indices->_list[i];
        printf("%s, votes(%d)\n", candidate->_name, candidate->_ballots._count);
    }
}


void output(Case* cases, int num_cases)
{
    int i;
    for (i = 0; i < num_cases; i++)
    {
        // LinkedList candidates;
        // ll_init(&candidates);
        CandidateList candidates;
        cl_init(&candidates);
        Case* current = cases + i;


        // go through the list of candidates' names
        int j;
        for (j = 0; j < current->_names._count; j++)
        {
            // save the current candidate's name
            Candidate* candidate = candidates._list+j;
            cn_init(candidate, current->_names._list[j], true, 0);


            // go through the list of ballots and record all the ballots
            // whose first choice is the current candidate
            int k;
            for (k = 0; k < current->_ballots._count; k++)
                if (current->_ballots._list[k]._list[0] == j+1)
                    bl_add_ballot(&candidate->_ballots,
                                  current->_ballots._list+k);
            if (_debug >= DEBUG_COPIOUS)
            {
                printf("CANDIDATE %s, with %d ballots:\n", candidate->_name,
                       candidate->_ballots._count);
                bl_print(&candidate->_ballots);
            }


            // save the current candidate
            // ll_add(&candidates, &candidate);
            candidates._count++;
        }
        if (_debug >= DEBUG_COPIOUS)
        {
            // ll_print(&candidates);
            printf("THE CANDIDATES:\n");
            cl_print(&candidates);
        }


        // while unable to find the winner
        //while (ll_find_winner(&candidates, current->_ballots._count) == false)
        while (cl_find_winner(&candidates, current->_ballots._count) == false)
        {
            // find the losers
            int min_votes = current->_ballots._count;
            IndexList indices;
            // for (node = candidates._head; node != 0; node = node->_next)
            int k;
            for (k = 0; k < candidates._count; k++)
            {
                if (candidates._list[k]._active)
                    if (candidates._list[k]._ballots._count < min_votes)
                    {
                        indices._list[0] = k;
                        indices._count = 1;
                        min_votes = candidates._list[k]._ballots._count;
                    }
                    else if (candidates._list[k]._ballots._count == min_votes)
                    {
                        indices._list[indices._count] = k;
                        indices._count++;
                    }
            }
            if (_debug >= DEBUG_COPIOUS)
                o_print(&indices, &candidates);


            for (k = 0; k < indices._count; k++)
{
printf("deactivate candidate %d, name: %s\n", indices._list[k], candidates._list[indices._list[k]]._name);
                candidates._list[indices._list[k]]._active = false;
}
/*
            // create a separate list of losers without removing them from
            // the original list of candidates
            // LinkedList losers;
            // LinkedList losers;
            // ll_init(&losers);
            CandidateList losers;
            for (k = 0; k < indices._count; k++)
                cn_init(losers._list+k,
                        candidates._list[indices._list[k]]._name,
                        false,
                        &candidates._list[indices._list[k]]._ballots);
            losers._count = indices._count;
            if (_debug >= DEBUG_COPIOUS)
            {
                printf("THE LOSERS:\n");
                cl_print(&losers);
            }
*/


            // from the list of losers, get the second-choice candidates
            // for (node = indices; node != 0; node = node->_next)
            for (k = 0; k < indices._count; k++)
            {
                // bl_shift_left(&losers._list[k]._ballots, &candidates);
                BallotList* ballots = &candidates._list[indices._list[k]]._ballots;
printf("CANDIDATES, PRE-SHIFT:\n");
cl_print(&candidates);
printf("BALLOTS of %s, PRE-SHIFT:\n", candidates._list[indices._list[k]]._name);
bl_print(ballots);
                bl_shift_left(ballots, &candidates);
printf("CANDIDATES, POST-SHIFT:\n");
cl_print(&candidates);
                int l;
                for (l = 0; l < candidates._count; l++)
{
printf("CANDIDATES, PRE-ADD:\n");
cl_print(&candidates);
printf("ADDING BALLOTS...\n");
bl_print(ballots);
printf("...TO BALLOTS:\n");
bl_print(&candidates._list[l]._ballots);
                    cn_add_ballots(candidates._list+l, ballots);
printf("CANDIDATES, POST-ADD:\n");
cl_print(&candidates);
}
            }
            if (_debug >= DEBUG_COPIOUS)
            {
                printf("THE REVISED CANDIDATES:\n");
                cl_print(&candidates);
            }

// break;

/*
*/
            // add the votes of these second choice candidates to the existing
            // list of active candidates
        }

/*
        ll_free(&candidates);
        ll_free(&losers);
*/
    }
}


void main(int argc, char** argv)
{
    char opt;
    char* input_file = 0;

    while ((opt = getopt(argc, argv, "i:d:")) != -1)
    {
        switch (opt)
        {
        case 'i':
            input_file = optarg;
            break;
        case 'd':
            _debug = atoi(optarg);
            break;
        default:
            printf("Usage: %s -i input_file [-d 0|1|2]\n", argv[0]);
        }
    }

    if (input_file == 0 || _debug < DEBUG_OFF || _debug > DEBUG_COPIOUS)
        printf("Usage: %s -i input_file [-d 0|1|2]\n", argv[0]);
    else
    {
        // Each case is represented by a huge struct, comprising an
        // array of 1000x20 integers and an array of 20x80 characters plus
        // 2 additional integers to keep count. So an array of 100 (MAX_CASES)
        // such cases causes a segmentation fault, apparently due to memory
        // allocation error. So I need to scale the size of the list from 100
        // to 20 cases at the most
        // Case list[MAX_CASES];
        Case list[10];
        int count;
        if (input(input_file, list, &count))
            output(list, count);
    }
}
